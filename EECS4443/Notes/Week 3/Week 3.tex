\documentclass[12pt]{book}

\usepackage[]{amsmath}
\usepackage[]{amsthm}
\usepackage[]{amsfonts}
\usepackage[]{amssymb}
\usepackage{blindtext}
\usepackage[a4paper, total={6in, 8in}]{geometry}

\usepackage{listings}
\usepackage{color}

\usepackage{graphicx}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\small\color{black},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=4
}

\graphicspath{{img}}

\title{EECS4443 Notes}
\author{Jerry Wu}
\date{2023-09-18}

\begin{document}

\maketitle

\section*{Layouts}

\subsection*{XML advantages}


\begin{itemize}
    \item XML is used exclusively for the view. We can separate concerns between function and form by using MVC.
    \item The ID attribute: \texttt{android:id="@+id/decbutton"} signifies that we are pulling a value, in this case, a button from the \texttt{R} (resources) class. 
    \item \texttt{R.java} is automatically generated based on what is in the XML view. This allows us to change a single value in the XML to change \textbf{all} occurences of that value in code.
\end{itemize}

\subsection*{Layout parameters}
An app activity can have multiple layouts.
\begin{itemize}
  \item Layouts take on the form of \texttt{layout\_foo}
  \item \texttt{LinearLayout}: every element is stacked sequentially on the screen depending on the orientation of the screen.
\end{itemize}

\subsection*{What is a layout?}
Simply put, a layout is what defines the UI elements in a given activity (screen). It is the \textbf{parent view} to all other elements within it. A \texttt{Layout} is a \texttt{ViewGroup}, and a \texttt{ViewGroup} is a \texttt{View}

\subsection*{Dynamic layout}
In a dynamic layout, the elements on the screen are not pre determined. In other words, \texttt{AdapterView} is used to populate the layout with views \textbf{at runtime} like \texttt{ListView}, \texttt{GridView}, etc. These are very common views for organizing data in many applications, since they display items in either a list or a grid respectively.
\begin{itemize}
  \item When scrolling through a list of elements, we don't want to have them all rendered at once, as that will cause performance issues (low memory). We can deal with these issues by using dynamic rendering. To achieve this, we only render what is on the screen at the moment (text, images, etc.) when they are scrolled to.
\end{itemize}

\subsection*{Tabs}

\begin{itemize}
  \item Tabs allow us to create muti paged activities
  \item All items are displayed concurrently
  \item Tabs should all be equal width with a text label
  \item Tabs are scrollable horizontally to find more pages within a single activity. In other words, we can switch between views without switching activities.
  \item They are NOT like tabs in a browser, because a tab in a browser can be considered as another activity, if nothing else.
\end{itemize}

\subsection*{Spinners}
\begin{itemize}
  \item It's like a \texttt{ListView}, but it is in the form of a dropdown menu.
\end{itemize}

\subsection*{Buttons}

\begin{itemize}
  \item We shouldn't use buttons too often since they have a heavy appearance. They are most suitable for important actions like sign up/log in.
  \item Rule of thumb is to not have more than 2 buttons on the screen at any given time.
\end{itemize}

\subsection*{Image buttons $>$ text buttons}

\begin{itemize}
  \item Image buttons are good for representing actions with easy to understand indicators such as a magnifying glass for search, etc.
  \item Image buttons save a lot of space.
  \item We can combine images and text in a button in order to add more context as to what the button does.
  \item Coloured image buttons are not necessary since users are used to interacting with objects. In fact, it is discouraged since it makes applications look archaic. 
  \item Same case applies to text buttons, however, the text colour should be different from the body text of the application so as to avoid roach motel (disguised links).
\end{itemize}

\subsection*{SeekBar, slider, and progress indicator}

\begin{itemize}
  \item Seekbar is good for increasing and decreasing continuous/discrete values like volume, brightness, timestamps in audio/video, etc. Though the former two are sliders.
  \item Progress indicators indicate how far a task has progressed such as download/install progress. Can only increase; fill from 0\% to 100\%.
  \item If we don't know exactly when the task will complete, we can use an \textbf{activity indicator} (spinning loading circle) to avoid giving the user false despair.
\end{itemize}

\subsection*{Switches}

\begin{itemize}
  \item \textbf{Checkbox} - used for selecting multiple options in a list, i.e. "select all that apply"
  \item \textbf{Radio button} - used for selecting exactly one option in a list, i.e. "select one"
  \item \textbf{On/off switch} - used for enabling/disabling certain features/settings within an application, i.e. "dark mode, wifi, mobile data, etc"
\end{itemize}

\textit{"If it's hell for spinners, it's even hell-ier with radio buttons" - M. Fokaefs 2023}

\subsection*{Dialogues}
\begin{itemize}
  \item Dialogues are used for information, alert, popups, feedback, etc. These should be used only for important prompts like info, settings, etc. since they put the current activity of the application on pause.
  \item \textbf{Toast}: A temporary lightweight popup that subtly alerts the user that something has happened. It automatically fades away.
\end{itemize}

\end{document}